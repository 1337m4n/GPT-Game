<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Colorful Snake</title>
<style>
html, body {
  margin: 0;
  height: 100%;
  background: radial-gradient(circle at center, #222, #000);
  display: flex;
  justify-content: center;
  align-items: center;
  color: #fff;
  font-family: sans-serif;
}
#score {
  position: absolute;
  top: 10px;
  left: 10px;
  font-size: 20px;
}
canvas {
  background: #111;
  box-shadow: 0 0 20px #ff008c;
}
#gameOver {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 48px;
  color: #ff4444;
  display: none;
  text-shadow: 0 0 10px #ff0000;
  text-align: center;
}
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="game" width="600" height="400"></canvas>
<div id="gameOver">Game Over<br/>Press Space to restart</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const gameOverEl = document.getElementById('gameOver');
const scale = 20;
const rows = canvas.height / scale;
const cols = canvas.width / scale;
let snake, direction, food, hue, score, over;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playBeep(){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.value = 440;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
  osc.stop(audioCtx.currentTime + 0.2);
}

function resetGame(){
  snake = [{x: Math.floor(cols/2), y: Math.floor(rows/2)}];
  direction = {x: 1, y: 0};
  food = spawnFood();
  hue = Math.random() * 360;
  score = 0;
  over = false;
  gameOverEl.style.display = 'none';
  loop();
}

function spawnFood(){
  let f;
  do {
    f = {x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows)};
  } while (snake.some(s => s.x === f.x && s.y === f.y));
  return f;
}

document.addEventListener('keydown', e => {
  if (over && e.key === ' ') { resetGame(); return; }
  switch(e.key){
    case 'ArrowUp': if(direction.y === 0) direction = {x:0, y:-1}; break;
    case 'ArrowDown': if(direction.y === 0) direction = {x:0, y:1}; break;
    case 'ArrowLeft': if(direction.x === 0) direction = {x:-1, y:0}; break;
    case 'ArrowRight': if(direction.x === 0) direction = {x:1, y:0}; break;
  }
});

function loop(){
  if (over) return;
  setTimeout(() => requestAnimationFrame(loop), 100);

  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,canvas.width, canvas.height);

  const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
  if(head.x < 0 || head.y < 0 || head.x >= cols || head.y >= rows ||
     snake.some(seg => seg.x === head.x && seg.y === head.y)){
    over = true;
    gameOverEl.style.display = 'block';
    return;
  }
  snake.unshift(head);

  if(head.x === food.x && head.y === food.y){
    playBeep();
    score++;
    food = spawnFood();
  } else {
    snake.pop();
  }

  ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
  ctx.fillRect(food.x*scale, food.y*scale, scale, scale);

  snake.forEach((seg, i) => {
    ctx.fillStyle = `hsl(${(hue + i*15) % 360}, 70%, 50%)`;
    ctx.fillRect(seg.x*scale, seg.y*scale, scale-1, scale-1);
  });

  hue = (hue + 2) % 360;
  scoreEl.textContent = 'Score: ' + score;
}

resetGame();
</script>
</body>
</html>

